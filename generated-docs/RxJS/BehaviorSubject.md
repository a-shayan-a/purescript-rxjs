## Module RxJS.BehaviorSubject

#### `BehaviorSubject`

``` purescript
data BehaviorSubject :: Type -> Type
```

Please see [RxJS Version 5.* documentation](http://reactivex.io/rxjs/) for
additional details on proper usage of the library.

##### Instances
``` purescript
Functor BehaviorSubject
Apply BehaviorSubject
Applicative BehaviorSubject
Bind BehaviorSubject
Monad BehaviorSubject
Semigroup (BehaviorSubject a)
Alt BehaviorSubject
```

#### `observeOn`

``` purescript
observeOn :: forall a. Scheduler -> BehaviorSubject a -> BehaviorSubject a
```

Makes every `next` call run in the new Scheduler.

#### `subscribeOn`

``` purescript
subscribeOn :: forall a. Scheduler -> BehaviorSubject a -> BehaviorSubject a
```

Makes subscription happen on a given Scheduler.

#### `subscribe`

``` purescript
subscribe :: forall a e. Subscriber a -> BehaviorSubject a -> Eff e Subscription
```

Subscribing to an BehaviorSubject is like calling a function, providing
`next`, `error` and `completed` effects to which the data will be delivered.

#### `subscribeNext`

``` purescript
subscribeNext :: forall a e. (a -> Eff e Unit) -> BehaviorSubject a -> Eff e Subscription
```

#### `just`

``` purescript
just :: forall a. a -> BehaviorSubject a
```

Creates an BehaviorSubject that emits the value specify,
and then emits a complete notification.  An alias for `of`.

#### `next`

``` purescript
next :: forall a e. a -> BehaviorSubject a -> Eff e Unit
```

Send a new value to a BehaviorSubject

#### `send`

``` purescript
send :: forall a e. a -> BehaviorSubject a -> Eff e Unit
```

An alias for next

#### `asObservable`

``` purescript
asObservable :: forall a. BehaviorSubject a -> Observable a
```

Create an Observable from a BehaviorSubject

#### `getValue`

``` purescript
getValue :: forall a e. BehaviorSubject a -> Eff e a
```

Obtain the current value of a BehaviorSubject

#### `buffer`

``` purescript
buffer :: forall a b. BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject (Array a)
```

Collects values from the first BehaviorSubject into an Array, and emits that array only when
second BehaviorSubject emits.

#### `bufferCount`

``` purescript
bufferCount :: forall a. Int -> Int -> BehaviorSubject a -> BehaviorSubject (Array a)
```

Collects values from the past as an array, emits that array when
its size (arg1) reaches the specified buffer size, and starts a new buffer.
The new buffer starts with nth (arg2) element of the BehaviorSubject counting
from the beginning of the *last* buffer.

#### `bufferToggle`

``` purescript
bufferToggle :: forall a b c. (BehaviorSubject a) -> (BehaviorSubject b) -> (b -> BehaviorSubject c) -> (BehaviorSubject (Array a))
```

Collects values from the source BehaviorSubject (arg1) as an array. Starts collecting only when
the opening (arg2) BehaviorSubject emits, and calls the closingSelector function (arg3) to get an BehaviorSubject
that decides when to close the buffer.  Another buffer opens when the
opening BehaviorSubject emits its next value.

#### `bufferWhen`

``` purescript
bufferWhen :: forall a b. BehaviorSubject a -> (a -> BehaviorSubject b) -> BehaviorSubject (Array a)
```

Collects values from the past as an array. When it starts collecting values,
it calls a function that returns an BehaviorSubject that emits to close the
buffer and restart collecting.

#### `concatMap`

``` purescript
concatMap :: forall a b. BehaviorSubject a -> (a -> BehaviorSubject b) -> BehaviorSubject b
```

Equivalent to mergeMap (a.k.a, `>>=`) EXCEPT that, unlike mergeMap,
the next bind will not run until the BehaviorSubject generated by the projection function (arg2)
completes.  That is, composition is sequential, not concurrent.
Warning: if source values arrive endlessly and faster than their corresponding
inner BehaviorSubjects can complete, it will result in memory issues as inner
BehaviorSubjects amass in an unbounded buffer waiting for their turn to be subscribed to.

#### `concatMapTo`

``` purescript
concatMapTo :: forall a b c. BehaviorSubject a -> BehaviorSubject b -> (a -> b -> BehaviorSubject c) -> BehaviorSubject c
```

The type signature explains it best.  Warning: Like `concatMap`, composition is sequential.

#### `exhaustMap`

``` purescript
exhaustMap :: forall a b. BehaviorSubject a -> (a -> BehaviorSubject b) -> BehaviorSubject b
```

It's Like concatMap (a.k.a, `>>=`) EXCEPT that it ignores every new projected
BehaviorSubject if the previous projected BehaviorSubject has not yet completed.

#### `expand`

``` purescript
expand :: forall a. BehaviorSubject a -> (a -> BehaviorSubject a) -> BehaviorSubject a
```

It's similar to mergeMap, but applies the projection function to every source
value as well as every output value. It's recursive.

#### `groupBy`

``` purescript
groupBy :: forall a b. (a -> b) -> BehaviorSubject a -> BehaviorSubject (BehaviorSubject a)
```

Groups the items emitted by an BehaviorSubject (arg2) according to the value
returned by the grouping function (arg1).  Each group becomes its own
BehaviorSubject.

#### `mapTo`

``` purescript
mapTo :: forall a b. b -> BehaviorSubject a -> BehaviorSubject b
```

Emits the given constant value on the output BehaviorSubject every time
the source BehaviorSubject emits a value.

#### `mergeMap`

``` purescript
mergeMap :: forall a b. BehaviorSubject a -> (a -> BehaviorSubject b) -> BehaviorSubject b
```

Maps each value to an BehaviorSubject, then flattens all of these BehaviorSubjects
using mergeAll.  It's just monadic `bind`.

#### `mergeMapTo`

``` purescript
mergeMapTo :: forall a b. BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject b
```

Maps each value of the BehaviorSubject (arg1) to the same inner BehaviorSubject (arg2),
then flattens the result.

#### `pairwise`

``` purescript
pairwise :: forall a. BehaviorSubject a -> BehaviorSubject (Array a)
```

Puts the current value and previous value together as an array, and emits that.

#### `partition`

``` purescript
partition :: forall a. (a -> Boolean) -> BehaviorSubject a -> Array (BehaviorSubject a)
```

Given a predicate function (arg1), and an BehaviorSubject (arg2), it outputs a
two element array of partitioned values
(i.e., [ BehaviorSubject valuesThatPassPredicate, BehaviorSubject valuesThatFailPredicate ]).

#### `scan`

``` purescript
scan :: forall a b. (a -> b -> b) -> b -> BehaviorSubject a -> BehaviorSubject b
```

Given an accumulator function (arg1), an initial value (arg2), and
a source BehaviorSubject (arg3), it returns an BehaviorSubject that emits the current
accumlation whenever the source emits a value.

#### `switchMap`

``` purescript
switchMap :: forall a b. BehaviorSubject a -> (a -> BehaviorSubject b) -> BehaviorSubject b
```

Projects each source value to an BehaviorSubject which is merged in the output
BehaviorSubject, emitting values only from the most recently projected BehaviorSubject.

#### `switchMapTo`

``` purescript
switchMapTo :: forall a b. BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject b
```

It's like switchMap, but maps each value to the same inner BehaviorSubject.

#### `window`

``` purescript
window :: forall a b. BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject (BehaviorSubject a)
```

It's like buffer, but emits a nested BehaviorSubject instead of an array.

#### `windowCount`

``` purescript
windowCount :: forall a. Int -> Int -> BehaviorSubject a -> BehaviorSubject (BehaviorSubject a)
```

It's like bufferCount, but emits a nested BehaviorSubject instead of an array.

#### `windowTime`

``` purescript
windowTime :: forall a. Int -> Int -> BehaviorSubject a -> BehaviorSubject (BehaviorSubject a)
```

It's like bufferTime, but emits a nested BehaviorSubject instead of an array,
and it doesn't take a maximum size parameter.  arg1 is how long to
buffer items into a new BehaviorSubject, arg2 is the when the next buffer should begin,
and arg3 is the source BehaviorSubject.

#### `windowToggle`

``` purescript
windowToggle :: forall a b c. (BehaviorSubject a) -> (BehaviorSubject b) -> (b -> BehaviorSubject c) -> (BehaviorSubject (Array a))
```

It's like bufferToggle, but emits a nested BehaviorSubject instead of an array.

#### `windowWhen`

``` purescript
windowWhen :: forall a b. BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject (BehaviorSubject a)
```

It's like bufferWhen, but emits a nested BehaviorSubject instead of an array.

#### `audit`

``` purescript
audit :: forall a b. BehaviorSubject a -> (a -> BehaviorSubject b) -> BehaviorSubject a
```

It's like auditTime, but the silencing duration is determined by a second BehaviorSubject.

#### `auditTime`

``` purescript
auditTime :: forall a. Int -> BehaviorSubject a -> BehaviorSubject a
```

Ignores source values for duration milliseconds,
then emits the most recent value from the source BehaviorSubject, then repeats this process.

#### `debounce`

``` purescript
debounce :: forall a. BehaviorSubject a -> (a -> BehaviorSubject Int) -> BehaviorSubject a
```

It's like debounceTime, but the time span of emission silence is determined
by a second BehaviorSubject.  Allows for a variable debounce rate.

#### `debounceTime`

``` purescript
debounceTime :: forall a. Int -> BehaviorSubject a -> BehaviorSubject a
```

It's like delay, but passes only the most recent value from each burst of emissions.

#### `distinct`

``` purescript
distinct :: forall a. BehaviorSubject a -> BehaviorSubject a
```

Returns an BehaviorSubject that emits all items emitted by the source BehaviorSubject
that are distinct by comparison from previous items.

#### `distinctUntilChanged`

``` purescript
distinctUntilChanged :: forall a. BehaviorSubject a -> BehaviorSubject a
```

Returns an BehaviorSubject that emits all items emitted by the source BehaviorSubject
that are distinct by comparison from the previous item.

#### `elementAt`

``` purescript
elementAt :: forall a. BehaviorSubject a -> Int -> BehaviorSubject a
```

Emits the single value at the specified index in a sequence of emissions
from the source BehaviorSubject.

#### `filter`

``` purescript
filter :: forall a. (a -> Boolean) -> BehaviorSubject a -> BehaviorSubject a
```

Filter items emitted by the source BehaviorSubject by only emitting those that
satisfy a specified predicate.

#### `ignoreElements`

``` purescript
ignoreElements :: forall a. BehaviorSubject a -> BehaviorSubject a
```

Ignores all items emitted by the source BehaviorSubject and only passes calls of complete or error.

#### `last`

``` purescript
last :: forall a. BehaviorSubject a -> BehaviorSubject a
```

Returns an BehaviorSubject that emits only the last item emitted by the source BehaviorSubject.

#### `sample`

``` purescript
sample :: forall a b. BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject a
```

It's like sampleTime, but samples whenever the notifier BehaviorSubject emits something.

#### `sampleTime`

``` purescript
sampleTime :: forall a. Int -> BehaviorSubject a -> BehaviorSubject a
```

Periodically looks at the source BehaviorSubject and emits whichever
value it has most recently emitted since the previous sampling, unless the source has not emitted anything since the previous sampling.

#### `skip`

``` purescript
skip :: forall a. Int -> BehaviorSubject a -> BehaviorSubject a
```

Returns an BehaviorSubject that skips n items emitted by an BehaviorSubject.

#### `skipUntil`

``` purescript
skipUntil :: forall a b. BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject a
```

Returns an BehaviorSubject that skips items emitted by the source BehaviorSubject until a second BehaviorSubject emits an item.

#### `skipWhile`

``` purescript
skipWhile :: forall a. (a -> Boolean) -> BehaviorSubject a -> BehaviorSubject a
```

Returns an BehaviorSubject that skips all items emitted
by the source BehaviorSubject as long as a specified condition holds true,
but emits all further source items as soon as the condition becomes false.

#### `take`

``` purescript
take :: forall a. Int -> BehaviorSubject a -> BehaviorSubject a
```

Emits only the first n values emitted by the source BehaviorSubject.

#### `takeUntil`

``` purescript
takeUntil :: forall a b. BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject a
```

Lets values pass until a second BehaviorSubject emits something. Then, it completes.

#### `takeWhile`

``` purescript
takeWhile :: forall a. (a -> Boolean) -> BehaviorSubject a -> BehaviorSubject a
```

Emits values emitted by the source BehaviorSubject so long as each value satisfies
the given predicate, and then completes as soon as this predicate is not satisfied.

#### `throttle`

``` purescript
throttle :: forall a b. BehaviorSubject a -> (a -> BehaviorSubject b) -> BehaviorSubject a
```

It's like throttleTime, but the silencing duration is determined by a second BehaviorSubject.

#### `throttleTime`

``` purescript
throttleTime :: forall a. Int -> BehaviorSubject a -> BehaviorSubject a
```

Emits a value from the source BehaviorSubject, then ignores subsequent source values
for duration milliseconds, then repeats this process.

#### `combineLatest`

``` purescript
combineLatest :: forall a b c. (a -> b -> c) -> BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject c
```

An BehaviorSubject of projected values from the most recent values from each input BehaviorSubject.

#### `concat`

``` purescript
concat :: forall a. BehaviorSubject a -> BehaviorSubject a -> BehaviorSubject a
```

Concatenates two BehaviorSubjects together by sequentially emitting their values, one BehaviorSubject after the other.

#### `concatAll`

``` purescript
concatAll :: forall a. BehaviorSubject (BehaviorSubject a) -> BehaviorSubject a
```

Converts a higher-order BehaviorSubject into a first-order BehaviorSubject by concatenating the inner BehaviorSubjects in order.

#### `exhaust`

``` purescript
exhaust :: forall a. BehaviorSubject (BehaviorSubject a) -> BehaviorSubject a
```

Flattens an BehaviorSubject-of-BehaviorSubjects by dropping the next inner BehaviorSubjects
while the current inner is still executing.

#### `merge`

``` purescript
merge :: forall a. BehaviorSubject a -> BehaviorSubject a -> BehaviorSubject a
```

Creates an output BehaviorSubject which concurrently emits all values from each input BehaviorSubject.

#### `mergeAll`

``` purescript
mergeAll :: forall a. BehaviorSubject (BehaviorSubject a) -> BehaviorSubject a
```

Converts a higher-order BehaviorSubject into a first-order BehaviorSubject
which concurrently delivers all values that are emitted on the inner BehaviorSubjects.

#### `race`

``` purescript
race :: forall a. Array (BehaviorSubject a) -> BehaviorSubject a
```

Returns an BehaviorSubject that mirrors the first source BehaviorSubject to emit an
item from the array of BehaviorSubjects.

#### `startWith`

``` purescript
startWith :: forall a. Array a -> BehaviorSubject a -> BehaviorSubject a
```

Returns an BehaviorSubject that emits the items in the given Array before
it begins to emit items emitted by the source BehaviorSubject.

#### `withLatestFrom`

``` purescript
withLatestFrom :: forall a b c. (a -> b -> c) -> BehaviorSubject a -> BehaviorSubject b -> BehaviorSubject c
```

Combines each value from the source BehaviorSubjects using a project function to
determine the value to be emitted on the output BehaviorSubject.

#### `zip`

``` purescript
zip :: forall a. Array (BehaviorSubject a) -> BehaviorSubject (Array a)
```

Waits for each BehaviorSubject to emit a value. Once this occurs, all values
with the corresponding index will be emitted. This will continue until at
least one inner BehaviorSubject completes.

#### `catch`

``` purescript
catch :: forall a. (BehaviorSubject a) -> (Error -> BehaviorSubject a) -> (BehaviorSubject a)
```

#### `retry`

``` purescript
retry :: forall a. Int -> BehaviorSubject a -> BehaviorSubject a
```

If the source BehaviorSubject calls error, this method will resubscribe to the
source BehaviorSubject n times rather than propagating the error call.

#### `delay`

``` purescript
delay :: forall a. Int -> BehaviorSubject a -> BehaviorSubject a
```

Time shifts each item by some specified amount of milliseconds.

#### `delayWhen`

``` purescript
delayWhen :: forall a b. BehaviorSubject a -> (a -> BehaviorSubject b) -> BehaviorSubject a
```

Delays the emission of items from the source BehaviorSubject by a given time
span determined by the emissions of another BehaviorSubject.

#### `dematerialize`

``` purescript
dematerialize :: forall a. BehaviorSubject (Notification a) -> BehaviorSubject a
```

#### `materialize`

``` purescript
materialize :: forall a. BehaviorSubject a -> BehaviorSubject (Notification a)
```

#### `performEach`

``` purescript
performEach :: forall a e. BehaviorSubject a -> (a -> Eff e Unit) -> Eff e (BehaviorSubject a)
```

Performs the effect on each value of the BehaviorSubject.  An alias for `do`.
Useful for testing (transparently performing an effect outside of a subscription).

#### `toArray`

``` purescript
toArray :: forall a. BehaviorSubject a -> BehaviorSubject (Array a)
```

#### `count`

``` purescript
count :: forall a. BehaviorSubject a -> BehaviorSubject Int
```

Counts the number of emissions on the source and emits that number when the source completes.


